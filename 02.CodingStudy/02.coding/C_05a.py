# 문제 설명
# 당신과 당신의 친구는 둘다 머리가 아주 좋은 광부이다. 둘은 광산에 들어가서 매일 금을 캐는데 둘은 매우 머리가 좋기때문에
# 조금 일하고 많은 금을 얻기위해 재밌는 게임을 한다. 게임은 다음과 같다. 매일 광산에서 캐는 금의 갯수와 무게는 다르다.
# 게임에 들어가기 전 각 금의 무게는 미리 측정하여 금의 무게를 써놓은 케이스에 붙여 놓았으며, 금은 각 케이스 안에 넣어 두었다.
# 금들을 시계방향으로 세운다음에 가져가는 게임이다. 단, 금을 가져갈때는 케이스를 열고 금만 가져간다.(금을 가져가도 게임판에 여전히 케이스는 남아 있다.)
#
# 당신의 금캐는 능력이 더 좋으므로 항상 먼저 금을 고르게 된다. 당신이 선택하고 나면 당신의 친구가 금을 고르고 다시 당신이 고르게 된다.
# 금이 전부 없어지고 빈케이스만 남아 있을때 까지 게임은 계속 된다. 어떤 그룹에서 당신이 금을 고르게 되면 당신이 금을 고른 그룹은
# 한개 혹은 두개의 그룹으로 나뉘어지게 되는데, 그룹은 '금이 들어있는 케이스가 최대로 연속된 그룹'으로 정의된다.

# 각각의 순서에서 금을 고르는 사람은 각 그룹에서 각각 1개씩 금을 가져가게된다.
#
# 그룹의 정의에 대한 이해를 돕기위하여 아래의 데이터를 살펴보자.
# {5,2,1,4,3,1}의 데이터를 그림으로 표현하면 아래와 같다.
#
#
#
# 이때, 만약 당신이 5kg(0번째)을 가져가고, 친구가 4kg(3번째)을 가져가게 되면, 2개의 그룹이 만들어 지게 된다.
# 이제 금이 들어있는 케이스가 최대로 연속된 그룹은 {2,1}, {3,1}로 나뉘어 지게 된다.
#
#
#
# 그래서 다음턴에 당신은 {2, 1} 에서 1개의 금, {3, 1}에서 1개의 금을 각각 가져갈 수 있게 된다.
# 위와 같이 만약 어떤 순서에 그룹이 n개가 있다면 각 n개의 그룹에서 1개씩 금을 가져가게 된다.
#
# 당신의 목표는 당신이 가져갈 금의 무게를 최대로 하는것이다. 원형으로 바닥에 놓은 금의 무게는 0부터 n-1까지 시계 방향순서대로 주어진다.
# 금의 무게들을 뜻하는 입력 파라미터의 이름은 goldValues 이다. 당신이 이 게임을 통하여 가져갈 수 있는 최대 금의 무게를 리턴하시오.
# 당신의 친구도 당신만큼 매우 똑똑하기 때문에, 완벽한 전략으로 게임을 한다고 가정한다.
#
# 참고 / 제약 사항
# goldValues의 요소의 갯수는 2개에서 100개 사이 이다.
# goldValues의 각 요소의 값은 1 <= goldValues[i] <= 10000 이다.
# 테스트 케이스
# goldValues = [5,2,1,4,3,1]리턴(정답): 10
# 당신은 먼저 5kg(0번째)의 금을 고른다. 당신의 친구는 4kg의 금을 고른다. 이제 {2, 1}과 {3, 1} 두개의 그룹이 되었다.
# 두 그룹에서 당신은 각각 2kg, 3kg을 가져가게 되고, 남은 1kg, 1kg은 당신의 친구가 가져가게 된다. 그래서 당신이 얻은 총 금은 5kg + 2kg + 3kg = 10kg이 된다.
#
# goldValues = [1,2,1]리턴(정답): 3
# 2kg(1번째)을 고른다. 당신의 친구가 남아있는 1kg을 고르고 나면 남아 있는 1kg은 당신의 것이다.
#
# goldValues = [2,1,4,1,2,1,8,1]리턴(정답): 12
# 8kg(6번째)을 고른다. 당신의 친구는 4kg(2번째)을 고른다. 이제 2개의 그룹으로 나뉘어지게 되었다. 각 그룹에서 2kg(0번째), 2kg(4번째)을 고른다.
# 이제 4개의 그룹이 있다. 당신의 친구가 각 그룹에 1개씩 남아있는 금을 전부 고른다.
#

class Solution:
    def solution(self, goldValues):
        p = max(goldValues)
        mypick = goldValues.index(max(goldValues))
        goldValues[goldValues.index(max(goldValues))] = 0
        oppick = goldValues.index(max(goldValues))
        goldValues[goldValues.index(max(goldValues))] = 0
        afterpick = goldValues
        afterpick.remove(mypick)
        afterpick.remove(oppick)
        while goldValues:
            if
            remain = [x for x in goldValues if goldValues.index(x)<mypick or goldValues.index(x) > oppick]
        return 0


item = [2,1,4,1,2,1,8,1]
p = max(item)
print(item.index(max(item)))
item[item.index(max(item))] = 0
item[item.index(max(item))] = 0
print(item)
